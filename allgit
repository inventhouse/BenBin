#!/usr/bin/env python3 -tt
# Copyright (c) 2018 Benjamin Holt -- MIT License

"""
Lightweight tool to work with many git repos.
"""
import argparse
import os
import os.path
from pathlib import PurePath
import re
import subprocess as sub  # FIXME: proper version check since sub.run is >=3.5?
import sys
#####


###  Main  ###
_name = "allgit"
_version = "v0.2"

def main(args, env):
    "Handle arguments, etc."
    mine, delim, cmd = split_args(args[1:], delims=("-", "--"))
    if cmd and delim == "-" and cmd[0] != "git":  # Git command must be separated by '-'...
        cmd[0:0] = ["git"]  # ...and may omit "git" which feels redundant on the command line
    # Non-git command must be separated by '--', but doesn't get anything magically added

    usage = f"""                                                       {_version}
    \t{_name} [options] [DIR ...] - [git] SUBCOMMAND
    \t{_name} [options] [DIR ...] -- ANY COMMAND
    \t{_name} -h/--help"""
    description = """Run a git command in all repositories in the current directory (or those specified); can also run other scripts or commands.
    """
    parser = argparse.ArgumentParser(usage=usage, description=description)
    parser.add_argument(
        "dirs",
        nargs="*",
        default=["."],
        metavar="DIR",
        help="Specific git repositories to work on or directories to search; defaults to the current directory.  Non-repository items are silently skipped and repositories are not searched for sub-repositories by default.",
    )
    parser.add_argument(
        "-b", "--branches",
        nargs="+",
        metavar="B",
        help="Only work on repositories which have at least one of these branches.",
    )
    parser.add_argument(
        "-d", "--depth",
        type=int,
        default=1,
        metavar="D",
        help="Depth to searsh for repositories; defaults to 1, meaning repositories directly sepecified or immidiately children of DIR.",
    )
    parser.add_argument(
        "-r", "--recursive",
        action="store_true",
        help="Search for repositories to any depth; synonym for '--depth -1 --subrepos'.",
    )
    parser.add_argument(
        "-s", "--subrepos",
        action="store_true",
        help="Search git repositories for repositories cloned as subdirectories.",
    )
    parser.add_argument(
        "--print-args",
        action="store_true",
        help="Print allgit arguments, command, and repos, then exit.",
    )
    parser.add_argument(
        '--version',
        action='version',
        version='%(prog)s ' + _version,
    )
    my_args = parser.parse_args(mine)

    if my_args.recursive:
        my_args.depth = -1
        my_args.subrepos = True

    found_repos = []
    for d in my_args.dirs:
        found_repos.extend(find_repos(d, depth=my_args.depth, subrepos=my_args.subrepos))

    repos = found_repos
    if my_args.branches:  # REM: checkout mode will work rather differently
        repos = [ r for r in found_repos if repo_branches(r, my_args.branches) ]

    if not found_repos:
        print("Warning: found no repositories")
    elif not repos:
        print(f"Warning: found {len(found_repos)} repositories but all were filtered out")

    if my_args.print_args:
        print(f"* Args:\n\t{my_args}\n* Command:\n\t{cmd}\n* Found Repos:\n\t{found_repos}")
        if my_args.branches:
            print(f"* Repos:\n\t{repos}")
        return 0

    xit = 0
    if repos and cmd:
        xit = run_for(repos, cmd)
    print("Done.")
    return xit


def split_args(args, delims=("--",)):
    "Splits the argument list on the first delimiter found; returns a tuple of the first arg list, that delimiter, and the second arg list"
    indexes = { args.index(d): d for d in delims if d in args }
    if not indexes:
        return (args, None, None)

    i = min(indexes.keys())
    before = args[:i]
    after = args[i + 1:]
    return (before, indexes[i], after)


def run_for(repos, cmd):
    "Run the command in all the repos, handle printing and errors"
    errors = []
    for r in repos:
        print(f"-----  {r}  -----")
        try:
            result = sub.run(cmd, cwd=r, stderr=sub.PIPE)  # Collect stderr so it can be printed at the end
        except FileNotFoundError as err:  # If the command is not found, this gets thrown instead of returning CP, so roll our own
            result = sub.CompletedProcess(cmd, returncode=err.errno, stderr=err.strerror)

        if result.returncode != 0:
            errors.append( (r, result) )
            print(result.stderr)  # REM: Should this go to our stderr?
        print("")

    xit = 0
    if errors:
        print("ERRORS:")
        for (repo, result) in errors:
            print(f"\t{repo}:\n{result.stderr}")  # REM: Should this go to our stderr?
            xit = result.returncode  # Return the last error code 'cos pick one
    return xit
####


###  Repos  ###
def find_repos(root, depth=1, subrepos=False):
    "Find repos in a directory, limited to 'depth' levels"
    start_depth = len(PurePath(root).parts)
    repos = []
    for current, dirs, files in os.walk(root):  # TODO: Maybe 'in/exclude' pattern option?
        is_bare_repo = current.endswith(".git")
        if is_bare_repo or ".git" in dirs:
            repos.append(current)
            dirs[:] = [ d for d in dirs if subrepos and not is_bare_repo and d != ".git" ]  # If searching for subrepos, don't search bare repos or .git
            continue

        current_depth = len(PurePath(current).parts)
        if depth >= 0 and current_depth - start_depth >= depth:
            dirs[:] = []  # Don't descend any deeper
            continue

    return sorted(repos)


def branch_repos(branch_list, repos):
    "Takes a list of branches and repos and returns a list of branches paired with lists of repos that have those branches"
    # branches = {}
    repo_branches_list = []
    for r in repos:
        repo_branches_list.append( (r, repo_branches(r, branch_list)) )

    branch_repos = []
    for b in branch_list:  # Invert the repo_branches_list
        branch_repos.append( (b, [ r for r, bl in repo_branches_list if b in bl ]) )  # Branches and repos stay in requested order

    return branch_repos


# '* master'
# '  remotes/origin/master'
BRANCH_RE = re.compile(r"^\*?\s*(remotes/[^/]*/)?")  # Match the star-space or space-space and optional 'remotes/*/' prefix to be stripped from branch names; assumes remote names do not contain '/'  # REM: maybe we can get a list of actual remote names to work against
def repo_branches(repo, branch_list=None):
    "returns a list of branch names for repo; remote branches are reduced to their base name (stripped of remotes/origin/) and de-duped.  If a list of desired branches is provided, only those will be returned if they exist for the repo"  # FIXME: this description is a mess
    branch_cmd = ["git", "branch", "--list", "--all",]
    if branch_list:
        branch_cmd.extend([ "*" + b for b in branch_list ])  # passing the list of branches to git pre-filters them for a small performance win, but also better debuggability; '*' wildcard matches /remotes/origin/ (and possibly other branches, but we re-filter anyway)
    result = sub.run(branch_cmd, cwd=repo, stdout=sub.PIPE, check=True)
    lines = [ s.decode("utf-8") for s in result.stdout.splitlines() ]
    branch_set = set([ BRANCH_RE.sub("", l) for l in lines ])
    if branch_list:
        return [ b for b in branch_list if b in branch_set ]  # Keep branches in the order they were requested
    else:
        return sorted(branch_set)
#####


#####
if __name__ == "__main__":
    _xit = main(sys.argv, os.environ)  # pylint: disable=invalid-name
    sys.exit(_xit)
#####
